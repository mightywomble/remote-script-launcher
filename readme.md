
# SSH Web Dashboard & Automation Hub

A powerful, self-hosted web interface for managing SSH hosts, executing commands, and automating complex workflows. This Flask application provides a centralized dashboard to manually run or schedule scripts across multiple servers, with AI-powered assistance for script generation and output analysis.

## Summary

This tool is designed for DevOps engineers, system administrators, and developers who need to manage multiple remote Linux servers efficiently. It replaces the need for manual SSH sessions by providing a clean, web-based UI to run commands, manage a library of version-controlled scripts, and build, run, and schedule complex automation pipelines. The integration with the Gemini API adds a layer of intelligence, helping users generate complex scripts from natural language and understand command outputs without leaving the application.

## Features

-   **Centralized Host Management**:
    
    -   Add, edit, and delete SSH hosts with a friendly name, hostname, and username.
        
    -   Test SSH connectivity to any host with a single click.
        
    -   Visually manage all your servers from a single pane.
        
-   **Advanced Command & Script Execution**:
    
    -   A central editor for writing and running commands.
        
    -   **Run as Sudo**: Execute commands with elevated privileges.
        
    -   Select multiple hosts to run commands or scripts on simultaneously.
        
    -   View real-time results and error outputs from each host.
        
-   **AI-Powered Script Suggestion**:
    
    -   Click the "Suggest Script" (<i class="fas fa-lightbulb"></i>) button to open a dialog.
        
    -   Describe a task in natural language (e.g., "find all files larger than 1GB").
        
    -   The AI generates options for a **Bash Command**, **Bash Script**, **Python Script**, and **Ansible Playbook**.
        
    -   Load any suggestion directly into the editor to test, use, or save.
        
-   **AI-Powered Output Analysis**:
    
    -   After running a command, click the "AI Analyze" button.
        
    -   Get a concise summary and troubleshooting tips for the command's output, generated by the Gemini API.
        
-   **Visual Pipeline Builder**:
    
    -   A drag-and-drop interface to build complex workflows.
        
    -   Visually connect hosts, scripts, AI actions, and notifications with success/failure paths.
        
    -   **Live YAML Generation**: See a GitHub Actions-style YAML representation of your pipeline as you build it.
        
    -   **Live Run/Dry Run**: Execute pipelines and see the output for each step in real-time, complete with progress bars, just like a CI/CD system.
        
-   **Version-Controlled Script Library**:
    
    -   **Local & GitHub Sources**: Manage scripts stored locally in the app's database or pull them directly from a connected GitHub repository.
        
    -   **Push to GitHub**: Push local scripts to a development branch in your repository with a commit message, right from the UI.
        
    -   **Directory-Based Organization**: The GitHub integration scans for scripts in predefined folders (`bash_scripts`, `python_scripts`, etc.) for better organization.
        
    -   **Sync on Demand**: Refresh the GitHub script list with a single click.
        
-   **Task Scheduling & Automation**:
    
    -   Schedule any saved script to run on a specific host at a recurring time (daily).
        
    -   View, manage, and delete saved schedules.
        
    -   **Discord & Email Integration**: Automatically sends a report to a configured Discord webhook and/or email address after a scheduled task runs, including the AI summary and any output/errors.
        
-   **Zabbix Integration**:
    
    -   A dedicated, secure API endpoint (`/api/zabbix-trigger`) allows Zabbix (or any other monitoring tool) to trigger remediation scripts automatically in response to alerts.
        
-   **Secure Configuration**:
    
    -   A collapsible settings panel to securely store your Gemini API Key, Discord Webhook URL, SMTP credentials, and GitHub details. Keys and passwords are never exposed in the browser.
        

## Tech Stack

-   **Backend**: Flask, Flask-SocketIO (Python)
    
-   **Scheduling**: APScheduler
    
-   **Configuration Management**: Ansible
    
-   **SSH Operations**: Paramiko
    
-   **API Calls**: Requests
    
-   **Database**: Flask-SQLAlchemy (with SQLite as the default database)
    
-   **Frontend**: Vanilla JavaScript, HTML5, CSS3, Leader-Line-New, js-yaml
    
-   **Icons**: Font Awesome
    

## Project Structure

```
.
├── static/
│   ├── style.css
│   └── app.js
│   └── pipeline.js
├── templates/
│   ├── index.html
│   └── pipeline.html
├── app.py
├── scheduler.py
├── pipeline.py
├── git_scripts.py
├── run_pipeline.py
├── models.py
├── config.json         # (auto-generated)
└── app.db              # (auto-generated)

```

## Setup and Installation

Follow these steps to get the application running locally.

**Prerequisites**:

-   An Ubuntu/Debian-based system (or similar Linux distribution).
    
-   Python 3.6+
    
-   Ansible must be installed and available in the system's PATH.
    
-   A configured SSH key pair on the machine running the application.
    

**Step 1: Install System Dependencies (for Ubuntu/Debian)**

```
sudo apt update && sudo apt install python3-pip python3-venv ansible -y

```

**Step 2: Clone the Repository**

```
git clone <your-repository-url>
cd <repository-folder>

```

**Step 3: Create and Activate a Virtual Environment**

```
# Create the virtual environment
python3 -m venv venv

# Activate it
source venv/bin/activate

```

**Step 4: Install Python Packages**

With the virtual environment active, install all the required Python libraries.

```
pip install Flask Flask-SQLAlchemy Paramiko requests APScheduler Flask-SocketIO PyGithub

```

## Running the Application

This application requires **two separate processes** to be running in two different terminals for all features to work.

**Terminal 1: Start the Web Server**

This process runs the main Flask application and serves the web interface.

```
python3 app.py

```

The web UI will be accessible at: [**http://127.0.0.1:5012**](https://www.google.com/search?q=http://127.0.0.1:5012 "null")

**Terminal 2: Start the Scheduler**

This process runs in the background to execute your scheduled tasks.

```
python3 scheduler.py

```

_Note: The scheduler must be restarted to activate new or remove deleted schedules._

## GitHub Repository Structure

For the GitHub integration to work correctly, your script repository should be organized with the following folder structure. The application will scan these specific directories for scripts.

```
your-repo/
├── bash_scripts/
│   ├── check_disk.sh
│   └── update_packages.sh
├── python_scripts/
│   └── get_cpu_usage.py
├── ansible_playbooks/
│   └── deploy_app.yml
└── pipelines/
    └── daily_cleanup.yml

```

## Security Considerations

-   **SSH Authentication**: This application is built with the assumption that you are using **SSH key-